/**
 * Generated by orval v7.5.0 🍺
 * Do not edit manually.
 * Log Viewer API
 * API for fetching and uploading logs
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query'
import type {
  DeleteLogs200,
  DeleteLogs500,
  GetLogs200,
  GetLogsAggregate200Item,
  GetLogsAggregate400,
  GetLogsAggregate500,
  GetLogsAggregateParams,
  GetLogsParams,
  PostUpload200,
  PostUpload400,
  PostUpload500,
  PostUploadBody
} from '../logViewerAPI.schemas'
import { customFetcher } from '../../mutator';



/**
 * Retrieves aggregated log data grouped by a specific field and timeframe.
 * @summary Get aggregated log data
 */
export const getLogsAggregate = (
    params: GetLogsAggregateParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<GetLogsAggregate200Item[]>(
      {url: `/logs/aggregate`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetLogsAggregateQueryKey = (params: GetLogsAggregateParams,) => {
    return [`/logs/aggregate`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLogsAggregateQueryOptions = <TData = Awaited<ReturnType<typeof getLogsAggregate>>, TError = GetLogsAggregate400 | GetLogsAggregate500>(params: GetLogsAggregateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsAggregate>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLogsAggregateQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogsAggregate>>> = ({ signal }) => getLogsAggregate(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLogsAggregate>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLogsAggregateQueryResult = NonNullable<Awaited<ReturnType<typeof getLogsAggregate>>>
export type GetLogsAggregateQueryError = GetLogsAggregate400 | GetLogsAggregate500


export function useGetLogsAggregate<TData = Awaited<ReturnType<typeof getLogsAggregate>>, TError = GetLogsAggregate400 | GetLogsAggregate500>(
 params: GetLogsAggregateParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsAggregate>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogsAggregate>>,
          TError,
          Awaited<ReturnType<typeof getLogsAggregate>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLogsAggregate<TData = Awaited<ReturnType<typeof getLogsAggregate>>, TError = GetLogsAggregate400 | GetLogsAggregate500>(
 params: GetLogsAggregateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsAggregate>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogsAggregate>>,
          TError,
          Awaited<ReturnType<typeof getLogsAggregate>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLogsAggregate<TData = Awaited<ReturnType<typeof getLogsAggregate>>, TError = GetLogsAggregate400 | GetLogsAggregate500>(
 params: GetLogsAggregateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsAggregate>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get aggregated log data
 */

export function useGetLogsAggregate<TData = Awaited<ReturnType<typeof getLogsAggregate>>, TError = GetLogsAggregate400 | GetLogsAggregate500>(
 params: GetLogsAggregateParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogsAggregate>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLogsAggregateQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Upload log CSV file
 */
export const postUpload = (
    postUploadBody: PostUploadBody,
 signal?: AbortSignal
) => {
      
      const formData = new FormData();
formData.append('file', postUploadBody.file)

      return customFetcher<PostUpload200>(
      {url: `/upload`, method: 'POST',
      headers: {'Content-Type': 'multipart/form-data', },
       data: formData, signal
    },
      );
    }
  


export const getPostUploadMutationOptions = <TError = PostUpload400 | PostUpload500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUpload>>, TError,{data: PostUploadBody}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof postUpload>>, TError,{data: PostUploadBody}, TContext> => {
    
const mutationKey = ['postUpload'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postUpload>>, {data: PostUploadBody}> = (props) => {
          const {data} = props ?? {};

          return  postUpload(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostUploadMutationResult = NonNullable<Awaited<ReturnType<typeof postUpload>>>
    export type PostUploadMutationBody = PostUploadBody
    export type PostUploadMutationError = PostUpload400 | PostUpload500

    /**
 * @summary Upload log CSV file
 */
export const usePostUpload = <TError = PostUpload400 | PostUpload500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postUpload>>, TError,{data: PostUploadBody}, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof postUpload>>,
        TError,
        {data: PostUploadBody},
        TContext
      > => {

      const mutationOptions = getPostUploadMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * @summary Get paginated logs
 */
export const getLogs = (
    params?: GetLogsParams,
 signal?: AbortSignal
) => {
      
      
      return customFetcher<GetLogs200>(
      {url: `/logs`, method: 'GET',
        params, signal
    },
      );
    }
  

export const getGetLogsQueryKey = (params?: GetLogsParams,) => {
    return [`/logs`, ...(params ? [params]: [])] as const;
    }

    
export const getGetLogsQueryOptions = <TData = Awaited<ReturnType<typeof getLogs>>, TError = unknown>(params?: GetLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogs>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetLogsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getLogs>>> = ({ signal }) => getLogs(params, signal);

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getLogs>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GetLogsQueryResult = NonNullable<Awaited<ReturnType<typeof getLogs>>>
export type GetLogsQueryError = unknown


export function useGetLogs<TData = Awaited<ReturnType<typeof getLogs>>, TError = unknown>(
 params: undefined |  GetLogsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogs>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogs>>,
          TError,
          Awaited<ReturnType<typeof getLogs>>
        > , 'initialData'
      >, }

  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLogs<TData = Awaited<ReturnType<typeof getLogs>>, TError = unknown>(
 params?: GetLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogs>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getLogs>>,
          TError,
          Awaited<ReturnType<typeof getLogs>>
        > , 'initialData'
      >, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGetLogs<TData = Awaited<ReturnType<typeof getLogs>>, TError = unknown>(
 params?: GetLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogs>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get paginated logs
 */

export function useGetLogs<TData = Awaited<ReturnType<typeof getLogs>>, TError = unknown>(
 params?: GetLogsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getLogs>>, TError, TData>>, }

  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGetLogsQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Delete all logs
 */
export const deleteLogs = (
    
 ) => {
      
      
      return customFetcher<DeleteLogs200>(
      {url: `/logs`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteLogsMutationOptions = <TError = DeleteLogs500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLogs>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteLogs>>, TError,void, TContext> => {
    
const mutationKey = ['deleteLogs'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteLogs>>, void> = () => {
          

          return  deleteLogs()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteLogsMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLogs>>>
    
    export type DeleteLogsMutationError = DeleteLogs500

    /**
 * @summary Delete all logs
 */
export const useDeleteLogs = <TError = DeleteLogs500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLogs>>, TError,void, TContext>, }
): UseMutationResult<
        Awaited<ReturnType<typeof deleteLogs>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getDeleteLogsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    